---
layout: post
title: currry&&异步等高频前端
date: 2022-07-17
author: 边黎安
header-img: img/tag-bg.jpg
catalog: true
tags:
  - web
  - 前端
---

## curry 化函数的实现

#### 1.1

curried 函数是个一次一个的去获取多个参数的函数。 再明白点，就是比如 给定一个带有 3 个参数的函数，curried 版的函数将接受一个参数并返回一个接受下一个参数的函数，该函数返回一个接受第三个参数的函数。最后一个函数返回将函数应用于其所有参数的结果。

看下面的例子，例如，给定两个数字，a 和 b 为 curried 形式，返回 a 和 b 的总和

```
// add = a => b => Number
const add = a => b => a + b;
```

```
什么意思？简单来说，柯里化是一项技术，它用来改造多参数的函数。比如：

// 这是一个接受 3 个参数的函数
const add = function(x, y, z) {
return x + y + z
}

// 接收一个单一参数
const curryingAdd = function(x) {
// 并且返回接受余下的参数的函数
return function(y, z) {
return x + y + z
}
}

// 调用add
add(1, 2, 3)

// 调用curryingAdd
curryingAdd(1)(2, 3)
// 看得更清楚一点，等价于下面
const fn = curryingAdd(1)
fn(2, 3)


const curryingAdd = function(x) {
  return function(y) {
    return function(z) {
      return x + y + z
    }
  }
}
// 调用
curryingAdd(1)(2)(3)
// 即
const fn = curryingAdd(1)
const fn1 = fn(2)
fn1(3)


```

#### 什么是部分功能

部分应用程序( partial application )是一个已应用于某些但并不是全部参数的函数。直白的来说就是一个在闭包范围内固定了(不变)的一些参数的函数。具有一些参数被固定的功能被认为是部分应用的。

#### 有什么不同？

部分功能(partial application)可以根据需要一次使用多个或几个参数。
柯里化函数(curried function)每次返回一个一元函数: 每次携带一个参数的函数。

所有 curried 函数都返回部分应用程序，但并非所有部分应用程序都是 curried 函数的结果。

#### 什么是 point-free 风格

point-free 是一种编程风格，其中函数定义不引用函数的参数。

我们先来看看 js 中函数的定义:
参数复用
工作中会遇到的需求：通过正则校验电话号、邮箱、身份证是否合法等等

于是我们会封装一个校验函数如下：

```
/**
 * @description 通过正则校验字符串
 * @param {RegExp} regExp 正则对象
 * @param {String} str 待校验字符串
 * @return {Boolean} 是否通过校验
 */
function checkByRegExp(regExp, str) {
    return regExp.test(str)
}

```

假如我们要校验很多手机号、邮箱，我们就会这样调用：

// 校验手机号
checkByRegExp(/^1\d{10}$/, '15152525634'); 
checkByRegExp(/^1\d{10}$/, '13456574566');
checkByRegExp(/^1\d{10}$/, '18123787385'); 
// 校验邮箱
checkByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/, 'fsds@163.com');
checkByRegExp(/^(\w)+(\.\w+)_@(\w)+((\.\w+)+)$/, 'fdsf@qq.com');
checkByRegExp(/^(\w)+(\.\w+)_@(\w)+((\.\w+)+)$/, 'fjks@qq.com');
貌似没什么问题，事实上还有改进的空间

校验同一类型的数据时，相同的正则我们写了很多次。
代码可读性较差，如果没有注释，我们并不能一下就看出来正则的作用
我们试着使用函数柯里化来改进：

// 将函数柯里化
function checkByRegExp(regExp) {
return function(str) {
return regExp.test(str)
}
}
于是我们传入不同的正则对象，就可以得到功能不同的函数：

// 校验手机
const checkPhone = curryingCheckByRegExp(/^1\d{10}$/)
// 校验邮箱
const checkEmail = curryingCheckByRegExp(/^(\w)+(\.\w+)*@(\w)+((\.\w+)+)$/)
现在校验手机、邮箱的代码就简单了，并且可读性也增强了

// 校验手机号
checkPhone('15152525634');
checkPhone('13456574566');
checkPhone('18123787385');
// 校验邮箱
checkEmail('fsds@163.com');
checkEmail('fdsf@qq.com');
checkEmail('fjks@qq.com');
这就是参数复用：我们只需将第一个参数 regExp 复用，就可以直接调用有特定功能的函数

通用函数(如 checkByRegExp)解决了兼容性问题，但也会带来使用的不便，比如不同的应用场景需要传递多个不同的参数来解决问题

实现思路
通过闭包的方式储存传入参数
通过函数的 length 属性获得参数个数
当参数个数不够时直接返回方法
存储的参数个数等于原函数参数个数时执行原函数
如果使用 ES6 参数默认值，length 将不等于实际参数个数
参数由 arguments 获取，ES6 直接使用 rest 参数实现

```
function curry(fn){
let len = fn.length
let args = []

return function currFun(...currFunArgs){
args = args.concat(currFunArgs)
if (args.length > len){

            throw new Error('arguments length error')
}
if(args.length ===  len){
  return fn(...args)
}
return currFun
}
}

```

## promise.all 的实现

```
Promise.all = function(promises) {
  let results = [];
  return new Promise(function(resolve) {
      promises.forEach(function(val) {
      // 按顺序执行每一个Promise操作
      val.then(function(res) {
        results.push(res);
      });
    });
    resolve(results);
  });
}


一、Promise.all传递的参数可能不是Promise类型，可能不存在then方法。
二、如果中间发生错误，应该直接返回错误，不执行后面操作

Promise.prototype.all = function(promises) {
  let results = [];
  let promiseCount = 0;
  let promisesLength = promises.length;
  return new Promise(function(resolve, reject) {
    for (let val of promises) {
      Promise.resolve(val).then(function(res) {
        promiseCount++;
        // results.push(res);
        results[i] = res;
        // 当所有函数都正确执行了，resolve输出所有返回结果。
        if (promiseCount === promisesLength) {
          return resolve(results);
        }
      }, function(err) {
        return reject(err);
      });
    }
  });
};

总结
Promise.all实现不难，只要了解它做了哪些事情，并且了解Promise的机制，就能大概猜出内部实现。
```

## 嵌套对象拍平连接成形如 a.b.c

## 异步任务执行管理，当同时需要执行多个异步任务时，需要你限制同时执行的异步任务数，就是异步并发控制

function fetch(url){
return new Promise(resolve => {
setTimeOut(()=>{

    })

})
}
function maxResquestLimit(urls, max, callback:()=>void){
const onceMaxFextn = urls.splice(0,max)

//map 转化
const onceMaxFetchArr = onceMaxFetchArr.map(url=> fetch(url))

Promise.all(onceMaxFetchArr).then(res => {
maxResquestLimit(urls, max, callback:()=>void)
})

}

---

Promise.all 并发限制
这时候考虑一个场景：如果你的 promises 数组中每个对象都是 http 请求，而这样的对象有几十万个。

那么会出现的情况是，你在瞬间发出几十万个 http 请求，这样很有可能导致堆积了无数调用栈导致内存溢出。

这时候，我们就需要考虑对 Promise.all 做并发限制。

>

```
function multiRequest(urls = [], maxNum) {
  // 请求总数量
  const len = urls.length;
  // 根据请求数量创建一个数组来保存请求的结果
  const result = new Array(len).fill(false);
  // 当前完成的数量
  let count = 0;

  return new Promise((resolve, reject) => {
    // 请求maxNum个
    while (count < maxNum) {
      next();
    }
    function next() {
      let current = count++;
      // 处理边界条件
      if (current >= len) {
        // 请求全部完成就将promise置为成功状态, 然后将result作为promise值返回
        !result.includes(false) && resolve(result);
        return;
      }
      const url = urls[current];
      console.log(`开始 ${current}`, new Date().toLocaleString());
      fetch(url)
        .then((res) => {
          // 保存请求结果
          result[current] = res;
          console.log(`完成 ${current}`, new Date().toLocaleString());
          // 请求没有全部完成, 就递归
          if (current < len) {
            next();
          }
        })
        .catch((err) => {
          console.log(`结束 ${current}`, new Date().toLocaleString());
          result[current] = err;
          // 请求没有全部完成, 就递归
          if (current < len) {
            next();
          }
        });
    }
  });

```

## 计算图形学 to frontend && node 的多路复用问题

node 的多路复用问题
一种更好的方法是，我们把这些内核一股脑扔给内核，并霸气的告诉内核：“我这里有 1 万个文件描述符，你替我监视着它们，有可以读写的文件描述符时你就告诉我，我好处理”。而不是弱弱的问内核：“第一个文件描述可以读写了吗？第二个文件描述符可以读写吗？第三个文件描述符可以读写了吗？”

这样应用程序就从“繁忙”的主动变为清闲的被动了，反正哪些设备 ok 了内核会通知我， 能偷懒我才不要那么勤奋。

所谓 I/O 多路复用指的是这样一个过程：

我们拿到了一堆文件描述符(不管是网络相关的、还是磁盘文件相关等等，任何文件描述符都可以)
通过调用某个函数告诉内核：“这个函数你先不要返回，你替我监视着这些描述符，当这堆文件描述符中有可以进行 I/O 读写操作的时候你再返回”
当调用的这个函数返回后我们就能知道哪些文件描述符可以进行 I/O 操作了。
那么有哪些函数可以用来进行 I/O 多路复用呢？

在 Linux 世界中有这样三种机制可以用来进行 I/O 多路复用：

select
poll
epoll

mmap
    mmap 是共享内存，用户进程和内核有一段地址(虚拟存储器地址)映射到了同一块物理地址上，这样当内核要对描述符上的事件进行检查的时候就不用来回的拷贝了。

红黑树
     红黑树是用来存储这些描述符的。当内核初始化 epoll 的时候（当调用 epoll_create 的时候内核也是个 epoll 描述符创建了一个文件，毕竟在 Linux 中一切都是文件，而 epoll 面对的是一个特殊的文件，和普通文件不同），会开辟出一块内核缓冲区，这块区域用来存储我们要监管的所有的 socket 描述符，当然在这里面存储有一个数据结构，这就是红黑树，由于红黑树的接近平衡的查找，插入，删除能力，在这里显著的提高了对描述符的管理。

rdlist
        rdlist 就绪描述符链表这是一个双链表，epoll_wait()函数返回的也是这个就绪链表。当内核创建了红黑树之后，同时也会建立一个双向链表 rdlist，用于存储准备就绪的描述符，当调用 epoll_wait 的时候在 timeout 时间内，只是简单的去管理这个 rdlist 中是否有数据，如果没有则睡眠至超时，如果有数据则立即返回并将链表中的数据赋值到 events 数组中。这样就能够高效的管理就绪的描述符，而不用去轮询所有的描述符。

当执行 epoll_ctl 时除了把 socket 描述符放入到红黑树中之外，还会给内核中断处理程序注册一个回调函数，告诉内核，当这个描述符上有事件到达（或者说中断了）的时候就调用这个回调函数。这个回调函数的作用就是将描述符放入到 rdlist 中，所以当一个 socket 上的数据到达的时候内核就会把网卡上的数据复制到内核，然后把 socket 描述符插入就绪链表 rdlist 中。

Epoll 的两种模式：

1.  水平触发（LT）：使用此种模式，当数据可读的时候，epoll_wait()将会一直返回就绪事件。如果你没有处理完全部数据，并且再次在该 epoll 实例上调用 epoll_wait()才监听描述符的时候，它将会再次返回就绪事件，因为有数据可读。

2.  边缘触发（ET）：使用此种模式，只能获取一次就绪通知，如果没有处理完全部数据，并且再次调用 epoll_wait()的时候，它将会阻塞，因为就绪事件已经释放出来了。

ET 的效能更高，但是对程序员的要求也更高。在 ET 模式下，我们必须一次干净而彻底地处理完所有事件。

Node.js 的实现和问题
下面来看下针对多进程监听同一个端口的一些解决方式。

1. 主进程监听端口并接收请求，轮询分发(轮询模式)

2. 子进程竞争接收请求(共享模式)

3. 子进程负载均衡处理连接(SO_REUSEPORT 模式)

第一种方式就是主进程去监听这个端口，并且接收连接。它接收连接之后，通过一定的算法(比如轮询)分发给各个子进程。这种模式。它的一个缺点就是当流量非常大的时候，这个主进程就会成为瓶颈，因为它可能都来不及接收或者分发这个连接给子进程去处理。

第二种就是主进程创建监听 socket， 然后子进程通过 fork 的方式继承这个监听的 socket， 当有一个连接到来的时候，操作系统就唤醒所有的子进程，所有子进程会以竞争的方式接收连接。这种模式，它的缺点主要是有两个，第一个就是负载均衡的问题，因为操作系统唤醒了所有的进程，可能会导致某一个进程一直在处理连接，其他其它进程都没机会处理连接。然后另外一个问题就是惊群的问题，因为操作系统唤起了所有的进程，但是只有一个进程它会处理这个连接，然后剩下进程就会被无效地唤醒。这种方式会造成一定的性能的损失。

第三种通过 SO_REUSEPORT 这个标记来解决刚才提到的两个问题。在这种模式下，每个子进程都会有一个独立的监听 socket 和连接队列。当有一个连接到来的时候，操作系统会把这个连接分发给某一个子进程并且唤醒它。这样就可以解决惊群的问题，因为它只会唤醒一个子进程。又因为操作系统分发这个连接的时候，内部是有一个负载均衡的算法。所以这样的话又可以解决负载均衡的问题。

接下来我们看一下 Node.js 中的实现。

#### 1). 轮询模式。在这种模式下，主进程会 fork 多个子进程，然后每个子进程里面都会调用 listen 函数。但是 listen 函数不会监听一个端口，它会请求主进程监听这个端口，当有连接到来的时候，这个主进程就会接收这个连接，然后通过文件描述符的方式传给各个子进程去处理。

2). 共享模式 共享模式下，主进程同样还是会 fork 多个子进程，然后每个子进程里面还是会执行 listen 函数，但同样的这个 listen 函数不会监听一个端口，它会请求主进程创建一个 socket 并绑定到一个需要监听的地址，接着主进程会把这个 socket 通过文件描述符传递的方式传给多个子进程，这样就可以达到多个子进程同时监听同一个端口的效果。

通过刚才介绍，我们可以知道 Node.js 的服务器架构存在的问题。如果我们使用轮询模式，当流量比较大的时候，那么这个主进程就会成为系统瓶颈。如果我们使用共享模式，就会存在惊群和负载均衡的问题。不过在 Libuv 里面，可以通过设置 UV_TCP_SINGLE_ACCEPT 环境变量来一定程度缓解这个问题。当我们设置了这个环境变量。Libuv 在接收完一个连接的时候，它就会休眠一会，让其它进程也有接收连接的机会。

最后来总结一下，本文的内容。Node.js 里面通过 Libuv 解决了操作系统相关的问题。通过 V8 解决了执行 JS 和拓展 JS 功能的问题。通过模块加载器解决了代码加载还有组织的问题。通过多进程的服务器架构，使得 Node.js 可以利用多核，并且解决了多个进程监听同一个端口的问题。

最后来总结一下，本文的内容。Node.js 里面通过 Libuv 解决了操作系统相关的问题。通过 V8 解决了执行 JS 和拓展 JS 功能的问题。通过模块加载器解决了代码加载还有组织的问题。通过多进程的服务器架构，使得 Node.js 可以利用多核，并且解决了多个进程监听同一个端口的问题。

下面是一些资料，有兴趣的同学也可以看一下。

1. 基于 epoll + V8 的 JS 运行时 Just：

https://github.com/theanarkh/read-just-0.1.4-code

2. 基于 io_uring+ V8 的 JS 运行时 No.js：

https://github.com/theanarkh/No.js

3. 理解 Node.js 原理：

https://github.com/theanarkh/understand-nodejs

## 图形学

前端学习计算机图形学（上）
Tw93
Tw93
​
阿里巴巴 前端工程师
255 人赞同了该文章
序
来自 vczh 某计算机图形学问题的回答:

程序员的三大浪漫：操作系统、图形学、编译原理，学了都是用来给你开眼界的。这些都不是什么你不学就怎么样的课程，而是你想成为大牛，不学不行=\_,=

Web 前端技术中和图形学挂钩的大致是 CSS3 的动画变换、SVG、Canvas、WebGL 这一些东西，但是前端工程师大多只停留在上层 API 操作方面，对于图形学的原理，譬如 GPU、图像的表示、图像几何变换的原理、纹理、层次模型等可能不是很了解。

在整理完 SVG 新司机开车指南后，对底层的一些技术有一些兴趣，加上对这一块属于空白区，故花了几天时间对图形学基本进行学习，记录于此。

本文主要包括如下内容：

GPU
概念和历史

Graphics Processing Unit(GPU)，即图形处理器, 是一种专门在个人电脑、工作站、游戏机和一些移动设备上运行绘图运算工作的微处理器。

GPU 相关概念在 20 世纪 70 年代末就已经被提出，使用单片集成电路(monolithic)作为图形芯片，当时就已经被用于视频、游戏、动画方面，可以很快的对几张图片进行合成(也就只有这个功能…)；

到 80 年代末，基于数字信号处理芯片(digital signal processor chip)的 GPU 被研发出来，与前代相比速度更快、功能更强，但是价格很贵；

到 1998 年 NVIDIA 公司宣布 modern GPU 的研发成功，标志着 GPU 研发的历史性突破成为现实。modern GPU 使用晶体管(transistors)进行计算，在微芯片(microchip)中，GPU 所使用的晶体管已经远远超过 CPU。

之后就是一代一代的 modern GPU 被研制出来，且功能、运行速度不断增强。

GPU VS CPU

可能有人会问，我们已经有 CPU 用来解释计算机指令以及处理计算机软件中的数据了，为什么还要使用 GPU 呢？ 要解释这个可以从 CPU 和 GPU 的结构说起。

图片来自 NVIDIA CUDA 文档。其中绿色的是计算单元，橙红色的是存储单元，橙黄色的是控制单元。

从上图可以看到，GPU 基于大的吞吐量设计的，采用了数量众多的计算单元和超长的流水线，但只有非常简单的控制逻辑并省去了 Cache，在计算密集型的程序和易于并行的程序运行上有很大的优势；

CPU 基于低延时的设计，有强大的 ALU（算术运算单元），结构上不仅被 Cache 占据了大量空间，而且还有有复杂的控制逻辑和诸多优化电路，相比之下计算能力只是 CPU 很小的一部分。

CPU 的缩写是 Central Processing Unit, GPU 是 Graphics Processing Unit，表面可以理解为一个是公交司机，另外一个是专车司机，但是其实 GPU 相比 CPU 工作技术含量要低，用于计算量大、相比 CPU 技术含量低、重复很多次的工作。有人把 CPU 比作老教授，将 GPU 比作小学生，教授处理复杂任务的能力是碾压小学生的，但是对于没那么复杂的任务，还是顶不住人多的(有一种黑的味道…

汇总起来就是这样：

前端中的硬件加速

关于前端中的硬件加速其实是创建一个 Composited Layer 来开启 GPU 硬件加速，通过 GPU 进行渲染，解放 CPU，创建 Composited Layer 具体有如下方法：

3D 或透视变换(perspective transform)CSS 属性.
使用视频加速解码的<video>元素.
拥有 3D (WebGL) 上下文或加速的 2D 上下文的<canvas>元素
混合插件(如 Flash)
对自己的 opacity 做 CSS 动画或使用一个动画 webkit 变换的元素
拥有加速 CSS 过滤器的元素
元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)
元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)
在 chrome 中可以这样打开 Composited Laye：

图像表示
简介

什么是计算机图像学呢？在 Computer graphics (disambiguation)上面是这么说的：

Computer graphics are graphics created by computers and, more generally, the representation and manipulation of pictorial data by a computer.
也即 计算机图形学是由计算机创建的图形，更普遍地说是计算机对图形数据的表示和操作。

在这章中主要理清图片是如何通过数据和特定的数据格式来表示的，同时说明计算机中颜色是如何表示的？

假设我们想将我们看到的美景保存下来，通常都是将其拍成照片，考虑到存储成本，我们必须将其转换成一个有限大小 数字形式的模拟信号，这个转换的过程即抽样。抽样理论也是 GC 中一个比较重要的内容，此处有时间再详细讨论。

照片中我们看到的信息相比现实场景中所包含的信息肯定会小很多，同时也不会像现实中那样无限宽高，从而我们必须在准确性方面进行妥协，通过选用适当的方法来采样和存储我们的图像。

光栅图象表示

计算机图形学解决图像表示问题的方法是将图像（图片）分割成规则网格，我们称之为栅格。每个网格单元是一个“图像单元”，一个常与像素收缩的术语。像素是图像的原子单位，也即一个单一颜色体。

上图，通过光栅来表示数字图像，光栅说明这里有一个灰色图像，它的内容在内存中表示的灰度帧缓冲。存储在帧缓冲区中的值记录在离散刻度上的像素的强度（0 =黑色，255 =白色）。

我们平时所说的屏幕分辨率即图像中像素的数目，分辨率越大，图像的空间细节就越大。

帧缓冲器

我们用一个结构化的方法来存储每个像素的颜色值来表示一个图像。

帧缓冲最初的定义是指内存保留直接操作当前显示的图像。在早期的图形,需要特殊的硬件来存储足够的数据来代表的只是单一的形象。但是现在我们可以在内存中同时操纵成百上千的图片,从而“帧缓冲”逐渐用来描述任何一块代表一个图像的存储。

现在常见的帧缓冲有灰度帧缓冲、伪彩色帧缓冲、真彩色帧缓冲这三种。

灰度帧缓冲是最简单形式的一种，通过使用各种灰度梯度来编码像素。使用 8 位将像素编码为无符号整数，来表示 256 种不同的灰度阴影。

伪彩色帧缓冲是一种存储方案和灰度帧相同，但是可以用来表示彩色图像，也即 0−255 中每一个代表着一种特定的颜色，而不是代表灰色阴影。

真彩色帧缓冲也用来表示彩色图像，但是不是像伪彩色帧缓冲那样通过查找表的方式来表示颜色，而是将每个像素的 RGB 颜色值直接存储在帧缓冲区。如果我们使用 8 位（1 字节）来表示红色，绿色和蓝色特定颜色，那么每个像素将需要 24 位（3 字节）的存储空间。

颜色的表示

要想搞明白颜色，我们可以首先了解下我们的眼睛。

看图说话是这样的：
lens ：弹性透镜，我们眼睛通过它将光聚焦到视网膜；
retina ：视网膜，视网膜中有 fovea，是视网膜中视力最高的部分，是 rods 细胞和 cones 细胞的集中区，这两种特殊细胞（棒和锥）可以将光信息转换成电脉冲；
optic nerve ：视神经，转换成电脉冲的光信息通过视神经传到我们的大脑；
blind spot ：盲点，不含感光细胞的地方；
cones 锥细胞负责色觉，它有三种类型的圆锥体，都已经发展到对特定波长的光（蓝色、绿色、红色）有很高的敏感度。

红色，绿色和蓝色被称为“加法原色”，可以通过将不同数量的红，绿和蓝光叠加来获得其他的颜色。

RGB 颜色表示法

在上图中我们可以看到 Red+Green=Yellow，在前端中表示颜色通常使用 HEX 方式或者 RGB 方式，黄色表示为#FFFF00 或者 rgb(255,255,0)。那么为什么可以看到黄色呢？我们可以理解成，那个黄色的物体其实最不喜欢黄色，它将其他光都吸收了，将黄色反射出来了，从而黄色的窄波段光波进入了我们的眼睛，刺激了红色和绿色的圆锥体细胞，所以我们感觉物体是黄的。

前端中 rgba 表示颜色也比较常见，它是 RGB 色彩模型的一个扩展。这个缩写词代表红绿蓝三原色的首字母，Alpha 值代表颜色的透明度/不透明度，取值为 0-1。

HSL 颜色表示法

除了用 RBG 来表示颜色，还可以颜色三要素来表示，也即 HSL 颜色表示法，其中包含如下：

Hue：色相，指的是色彩的外相，是在不同波长的光照射下，人眼所感觉不同的颜色，如红色、黄色、蓝色等，这些颜色分布在一个平面的色相环上，取值范围是 0° 到 360° 的圆心角，每个角度可以代表一种颜色。

Saturation：饱和度，指色彩的纯度，越高色彩越纯，低则逐渐变灰。

Lightness：明度，又称亮度，指的是颜色的明暗。

同时也有 hsla，可以对比上述 rgba。

关于 RGB 和 HSL 的快速切换可以通过 chrome 来实现，按住 shift 再点击即可切换。

此外还有 HSV 来表示颜色，即色相、饱和度、明度（英语：Hue, Saturation, Value），又称 HSB，其中 B 即英语：Brightness。

几何变换
几何变换和 CSS3 中的 transform 变换相关，本节主要是从数学方面来给 transform 变换原理。

几何变换有时也被称为刚体变换, 即图形中所有的点均是在同一个变换下进行，可以从下图来区别是否为刚体变换：

其中图 2 经过图 1 反射得到、图 3 经过图 1 进行缩放和旋转组合的方式得到，然后图 4 是经过图一的枕形畸变(pin-cushion distortion)非刚体变换得到，请注意，只有刚体变换可以使用矩阵乘法来实现。

首先我们可以来复习下线性代数中的矩阵乘法:

结果矩阵第 m 行与第 n 列交叉位置的那个值，等于第一个矩阵第 m 行与第二个矩阵第 n 列，对应位置的每个值的乘积之和。同时它只有在第一个矩阵的列数和第二个矩阵的行数相同时才有意义。

以下例子都是用二维刚体图形的变换来讲述。

二维刚体变换
Scale

我们可以使用下面的缩放矩阵来对一个二维图形进行缩放处理：

其中[公式]和[公式]分别为在 X 轴和 Y 轴上面的缩放因数，当一个点[公式]和 M 进行矩阵相乘可以得到如下：[公式]。
当 Sx=Sy=2 时，我们可以理解此转换矩阵可以将原图放大一倍，当=1/2，将原图缩放一倍，同时我们也可以通过 Scale 来进行反射，当 Sx=-1，Sy=1 时候，即可实现图形沿 Y 轴进行反射。

Skew

Skew 的意思是指扭曲，斜切变换，实现它的变换矩阵最简单的是这样的：

也即一个点[公式]与它相乘可以得到：[公式]，也即将点的 x 分量移动与其 y 分量成比例 q 的量。

一些稍微复杂的 Skew 如下所示，大家可以想想用 CSS3 中的 transform: skew 如何实现。

Rotation

我们可以通过下面那个选中矩阵对一个多边形沿逆时针方向旋转 θ 度：

我们可以从下图看到一个点[公式]围绕原点逆时针旋转了 θ 度，点的[公式]拐角移动到点(cosθ,sinθ)T。

文献参考
Platform Independent Real-Time X3D Shaders and their Applications in Bioinformatics Visualization
GPGPU PROCESSING IN CUDA ARCHITECTURE
https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome
Color Models: RGB, HSV, HSL
色生心中：人性化的 HSL 模型 - 腾讯 CDC
颜色模型 | Garan no dou
理解矩阵乘法 - 阮一峰的网络日志
变换的矩阵表示形式

一个机器人位于一个横 X,竖 Y 网格的左上角 。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

public class LeetCodeUniquePath {
public static int uniquePath(int x,int y){
int nets[][] =new int[x][y];
//row
for(int i =0;i<x;i++){
//line
for(int j =0;j<y;j++){
if(i==0||j==0){
//corner init
nets[i][j]=1;
}else{
nets[i][j]=nets[i-1][j]+nets[i][j-1];
}
}
}
return nets[x-1][y-1];
}

    public static void main(String[] args) {
        int uniquePath = uniquePath(2, 3);
        System.out.println(uniquePath);
    }
